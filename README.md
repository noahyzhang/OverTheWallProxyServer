 OverTheWallProxyServer
基于socks5 协议一款服务器

在介绍我的项目之前呢，先简单的介绍一下中国的 GFW。叫做中国防火长城。

    GFW 的作用呢，就是部署在中国的边境用来分析与过滤中国境内外网络间的互相访问。他不仅能够限制国内网民访问境外的某些站点，也能限制国外用户访问国内的站点。
    在说之前我们先来了解几个专业的名词

DNS 污染和DNS 劫持

    我们访问网站是通过域名进行访问的，访问这个网站要通过DNS 服务器把域名解析成IP 地址，而DNS 服务器使用UDP 协议，没有任何认证机制。
    因此当你向你的DNS 服务器请求域名解析服务时，可能会被我劫持下来，并且返回一个伪造页面的IP 地址。这就是DNS 劫持
    同样的，当你向你的DNS 服务器请求域名解析服务时，假如我是DNS 服务器，我看到你要访问一个非法网站，那我就给你返回一个404，不存在的页面地址。
    比如：你使用电信或者移动运营商的宽带，默认你是不需要任何DNS 服务器的。因为DNS 服务器由他们提供，于是乎，一旦检测到你访问的网页是不允许访问的，他们就给你返回一个不存在的网页。
    如何解决：
    我可以使用第三方的DNS 服务器
    我可以自己使用VPS 搭建DNS 服务器
    我可以自己修改机器的host 文件，直接IP 访问
    但是，上面的办法都不行了，别急，看下方

封锁IP

    上面提到我们从DNS 上入手进行 穿过网关，但是我们的GFW 做了一件事，针对IP 进行封锁。你既使拿到了非法的IP地址，但是我把这个IP 封了，你咋出去。不过，像google 这样的公司服务器会有很多的镜像IP的，但是目前基本上全部被封锁了，不过也不可能把所有的国外IP 全部封锁，我们还是有机会从国内连接到国外的VPS，进行 穿过网关。
    解决方法：
    我们可以使用VPS 搭建代理
    我们可以使用IPv6，IPv6 地址巨大，想封也封不完，但是还没有普及

封锁HTTP 代理

    我们客户端可以不直接请求目标服务器，而是请求代理服务器，代理服务器再去请求目标服务器，然后返回结果。但是HTTP 传输的是明文，请求中有URL或IP 地址，很容易被检测到。对于HTTP ，虽然通信是加密的，但建立连接之前会给代理服务器发送connect 方法，也会带上要访问的远端服务器地址。如果服务器在国外，也会被检测到。当然服务器在国内，也出不去的呀。
    那么这样说，对于HTTP 代理，相当于在网络环境上裸奔。而HTTPS 能好一点，加密了数据，但是却可以知道你的数据去了哪里。
    解决办法：
    还是使用VPS 搭建 VPN
    或者使用第三方的VPN

封锁VPN

    既然我们都知道可以使用VPS 搭载VPN 来进行绕过GFW，那么我们也可以封锁VPN。虚拟专用网（英语：Virtual Private Network，简称VPN），是一种常用于连接中、大型企业或团体与团体间的私人网络的通讯方法。虚拟私人网络的讯息透过公用的网络架构（例如：互联网）来传送内联网的网络讯息。它利用已加密的通道协议（Tunneling Protocol）来达到保密、发送端认证、消息准确性等私人消息安全效果。 正常网络通信时，所有网络请求都是通过我们的物理网卡直接发送出去。
    而VPN是客户端使用相应的VPN协议先与VPN服务器进行通信，成功连接后就在操作系统内建立一个虚拟网卡，一般来说默认PC上所有网络通信都从这虚拟网卡上进出，经过VPN服务器中转之后再到达目的地. 通常VPN协议都会对数据流进行强加密处理，从而使得第三方无法知道数据内容，这样就实现了穿过GFW。
    穿过GFW 时VPN服务器知道你干的所有事情（就像HTTP一样，对于HTTPS，它知道你去了哪）。 VPN有多种协议：OPENVPN、PPTP、L2TP/IPSec、SSLVPN、IKEv2 VPN，Cisco VPN等。其中的PPTP和L2TP是明文传输协议。只负责传输，不负责加密。分别利用了MPPE和IPSec进行加密。
    因此，对于VPN和其他一些加密的传输的协议来说，没有办法直接获取明文的请求信息，所以没有办法直接封锁，而是使用了监控的方式。
    比如：

    暴力破解
    对于一些使用弱加密方式的协议来说，直接使用暴力破解检查传输内容。比如PPTP使用MPPE加密，但是MPPE是基于RC4，对于强大的防火墙背后的超级计算机集群，破解就是几秒钟的事情，破解后明文中一旦包含了违禁内容，请求就会被封。而对应的IP可能会进入重点关怀列表
    特征检测
    要想成功 的话都必须与对应的远程服务器建立连接，然后再用对应的协议进行数据处理并传输。而问题就出在这里：工具和远程服务器建立连接时，如果表现的很独特，在一大堆流量里很显眼，就会轻易被GFW识别出从而直接阻断连接，而VPN（尤其是OPENVPN）和SSH这方面的问题尤其严重
    流量监控
    当一个VPN地址被大量人请求，并保持长时间连接时，就很容易引起关注。SSH接口有大量数据请求。一般会结合其他特征。
    深度包检测：
    深度数据包检测（Deep packet inspection，缩写为 DPI），又称完全数据包探测（complete packet inspection）或信息萃取（Information eXtraction，IX），是一种电脑网络数据包过滤技术，用来检查通过检测点之数据包的数据部分（亦可能包含其标头），以搜索不匹配规范之协议、病毒、垃圾邮件、入侵，或以预定之准则来决定数据包是否可通过或需被路由至其他不同目的地，亦或是为了收集统计数据之目的。
    因此我们说想要 穿过GFW 可以借助国外的服务器VPS搭载VPN
    我们再来看一个协议

socks5协议

    SOCKS5 是一个代理协议，它在使用TCP/IP协议通讯的前端机器和服务器机器之间扮演一个中介角色，使得内部网中的前端机器变得能够访问Internet网中的服务器，或者使通讯更加安全。SOCKS5 服务器通过将前端发来的请求转发给真正的目标服务器， 模拟了一个前端的行为。在这里，前端和SOCKS5之间也是通过TCP/IP协议进行通讯，前端将原本要发送给真正服务器的请求发送给SOCKS5服务器，然后SOCKS5服务器将请求转发给真正的服务器。【百度百科解释】

socks代理和HTTP代理的异同

    提到socks 代理，那么就需要知道他和HTTP代理有什么异同了。然后，我讲两个故事来分享一下。

SOCKS：Bill希望通过互联网与Jane沟通，但他们的网络之间存在一个防火墙，Bill不能直接与Jane沟通。所以，Bill连接到他的网络上的SOCKS代理，告知它他想要与Jane创建连接；SOCKS代理打开一个能穿过防火墙的连接，并促进Bill和Jane之间的通信。
HTTP：Bill希望从Jane的Web服务器下载一个网页。Bill不能直接连接到Jane的服务器，因为在他的网络上设置了防火墙。为了与该服务器通信，Bill连接到其网络的HTTP代理。他的网页浏览器与代理通信的方式与他直接连接Jane的服务器的方式相同；也就是说，网页浏览器会发送一个标准的HTTP请求头。HTTP代理连接到Jane的服务器，然后将Jane的服务器返回的任何数据传回Bill。

    总结一下：SOCKS工作在比HTTP代理更低的层次：SOCKS使用握手协议来通知代理软件其客户端试图进行的连接SOCKS，然后尽可能透明地进行操作，而常规代理可能会解释和重写报头（例如，使用另一种底层协议，例如FTP；然而，HTTP代理只是将HTTP请求转发到所需的HTTP服务器）。虽然HTTP代理有不同的使用式，CONNECT方法允许转发TCP连接；然而，SOCKS代理还可以转发UDP流量和反向代理，而HTTP代理不能。HTTP代理通常更了解HTTP协议，执行更高层次的过滤（虽然通常只用于GET和POST方法，而不用于CONNECT方法）。
    --------------------------------------------------------------------------------------------
    
好了，终于将基础的知识说完了，现在开始介绍我的项目了。
数据通道转发过程
browser —> transfer server

    transfer server 接收 browser 数据，加密后转发给 socks5 server。加密数据可以躲过防火墙。

socks5 server —> google

    socks5 server接收transfer server的数据，先解密数据。再进入如下步骤：

    第一次数据过来，解析socks5协议头，进行身份认证auth，并回复客户端。
    第二次数据过来，解析socks5协议头，进行服务器信息解析，和 google server建立连接Establishment，并回复客户端。
    后续再发数据过来，则直接解密后，转发给google server

google server —> socks5 server

    socks5 server 接收 google server的数据，直接加密，转发给transfer server

transfer server —> browser

    transfer server 接收 socks5 server 的数据，先解密，再传输给 browser
通道数据的转发
    在数据转发的过程中，我做了一个比较巧妙的做法。我始终让发送数据的一方作为我的client 端，让我的接受数据的一方作为我的 server 端。
    在转发数据的过程中，需要对于recv 这个函数有一定的认识。小于0 的时候是函数自身报错。等于0 的时候需要注意，相当于是client 端向要我发起关闭连接的请求，也就是说此时我client 端不会再向server 端去写数据了。于是我socks5 服务器所应该做的操作就是关闭掉我socks5 服务器 server 端的写。
    问题还没有完，当我转发的时候我就一定可以将我拿到的数据全部转发出去吗？ 当然是不一定。这个要看对端的缓冲够不够，我方是否应该发送这么多数据。于是乎我做了这样的操作，我先去send，如果可以全部转发当然是好事，如果不能全部转发的话，我是这样操作的，大家还记得我的通道中不管的是client 还是server 的通道，我除了维护一个文件描述符之外，我还维护了一个缓冲区，这个时候它就要出场了，将没有写完的放到我的缓冲区中，然后修改我的event 事件，让他再次触发异步事件。
那我整体的描述一下我的socks5 项目

    我的项目的功能通过在非大陆的服务器，搭载我的项目。可以穿越GFW 而进行我们想做的事情了。
    我的项目分为五个模块。

1. Epoll 基类

    我的Epoll 基类模块干的事情，由于这个模块是为了我的transfer 模块和 socks 模块提供服务，因此我设置了可继承的函数，比如Start()，它是为了绑定我的套接字，并且创建我的 epoll 用来管理我的事件，同时将我的listen 套接字加入到 epoll 事件中去。当一切准备就绪后，我就进入了我的事件循环中去，于是我有一个函数 EventLoop()，处理我的Epoll 中的事件。
    当然我的Epoll 事件主要有三种，分别是请求连接事件、读事件、写事件。 其中处理我的连接事件和读事件的函数是纯虚函数，而我的写事件是我的Epoll 类所实现的虚函数。为什么要把请求连接事件和读事件设置为纯虚函数？是因为我的transfer 模块和 socks5 模块对于这两个函数所要实现的功能不一样。具体功能在模块中说。

2. Socks5 模块

    这个模块继承自Epoll 模块。并且这个模块主要是重写Epoll 类中的连接处理函数，还有Epoll 类中读事件处理的函数。
    对于socks5 服务来说，连接处理比较简单，只需要将我的文件描述符加到我的Epoll 事件中，并且设置好我的通道中的参数：连接的状态（身份认证状态）以及连接的客户端文件描述符。
    对于socks5服务器来说，读事件处理牵扯到对socks5 协议的认识。当读事件来的时候，我socks5 需要查看这个连接的状态，分别为身份认证状态、建立连接状态和转发状态。
        身份认证状态的包我收到之后，首先去解析这个包，检查是不是对应的socks5 协议的包。如果是，则把连接的状态改变成建立连接状态。最后给对端回一个数据包
        建立连接状态的包在我收到之后，这个时候我就需要和server 端建立连接了。于是乎我再解析我的数据包，数据包有三种情况，发过来的对端地址是IPv4、域名和IPv6。如果是IPv4 的话我直接拿到IP 和port 建立连接完事。当我拿到的是域名的时候，我通过 gethostbyname() 这个函数将域名解析成IP 地址，那个函数底层调用的就是DNS 服务器而已。目前我的项目没有处理IPv6 的情况。
        当建立好连接之后，我会将这个文件描述符加入到我的Epoll 事件中去，并且设置我这条连接的server 通道，设置 server 通道中的文件描述符，设置连接的状态为转发状态。
        当收到转发的包之后，这个转发的函数我是继承父类的转发函数，完成的功能也比较简单。将数据从客户端接受过来，然后发送给服务端。这块有很多问题，
            比如说，我接收数据，那么我一次性接收多少数据比较好？也就是说我的buff 设置多大比较好？设置小了，对端要发多次，效率低。设置大了，我转发的时候一次性可能转发不完？多次转发又要。。。。
            比如说，我接收数据一次性接收完了，好说。如果接收不完，又该怎么办？
            还需要处理如果我recv 到一个 0 ，又该怎么办？
            这些问题我还在下面的问题中谈。

3. Transfer 模块

    这个模块其实也算是一个服务，部署在我的brower 浏览器和socks服务器之间，说实际点就是放在我的本机上。拿到从我本机上出去的数据，然后转发给socks5 服务器。为什么要这样做呢？我不能直接连接socks5 服务器吗？？
    这个问题好，当然可以直接访问socks5 服务器，我们的功能是通过socks5 服务器实现访问google。我的转发模块最主要的工作转发前我对我的数据进行加密，收到数据时我再解密，为什么要加这一层呢？是因为我不想让我的数据在网络上裸奔。
    而且我的transfer 服务放在我本机上，网络上看到的数据永远是我加密后的数据。
    这个模块实现起来也比较简单。就是重写我Epoll 父类中建立连接函数和读事件函数。
        建立连接函数实现也比较简单，当有连接来的时候，我和socks5 服务器建立连接。然后拿到client 端和 server 端的两个文件描述符。首先将文件描述符设置为非阻塞，然后将两个文件描述符添加到Epoll 事件中，并且设置通道，将连接的状态改成转发状态，还有设置通道中国文件描述符。
        读事件函数更加简单。事件来了之后我只负责将连接好的通道的客户端数据转发到通道的服务端即可。调用我Epoll 父类中的转发函数即可。当然转发过程也会遇到socks5 服务器转发时遇到的问题。下面会谈到这个的。

4. 加密模块

    这个模块做的事情，就是服务我的转发模块。将我转发出去的数据进行加密，将我接收到的数据进行解密。
    我用到的加密算法也比较简单，这块是项目的一个弱点。只是简单的异或了一下。
    后期我会用更加有效的加密算法。

5. 日志模块

    这个模块和项目功能没有太大的关系。但是在调试过程中真的是少不了他啊。
    分别有一个跟踪流程的日志和错误的日志。
    定义 __ FILE__, __ LINE__, __ FUNCTION__, __ VA_ARGS__，这几个宏分别来获取到那个文件、那一行、那个函数、最后一个可变参数列表。

提出几个问题
问题一：

在我测试我的项目时，我总会遇到一个问题，我的服务器跑着跑着就挂了？

    我一直百思不得其接，不过还是我的日志功能起了大作用？我发现了一个问题。。
    TCP是全双工的信道, 可以看作两条单工信道, TCP连接两端的两个端点各负责一条. 当对端调用close时, 虽然本意是关闭整个两条信道, 但本端只是收到FIN包. 按照TCP协议的语义, 表示对端只是关闭了其所负责的那一条单工信道, 仍然可以继续接收数据. 也就是说, 因为TCP协议的限制, 一个端点无法获知对端的socket是调用了close还是shutdown.
    这句不太准确，虽然本端无法知道对端是close还是shutdown(S,SHUT_WR)，但是如果对端是close并且socket描述符的使用计数减为0的话，那么实际对端是关闭了两个信道。原因，实际下面已经讲了，对端如果close，相当于shutdow(S,SHUT_BOTH),本端如果再write的话，就会收到连接 RST 的。
    对一个已经收到FIN包的socket调用read方法, 如果接收缓冲已空, 则返回0, 这就是常说的表示连接关闭. 但第一次对其调用write方法时, 如果发送缓冲没问题, 会返回正确写入(发送). 但发送的报文会导致对端发送RST报文, 因为对端的socket已经调用了close, 完全关闭, 既不发送, 也不接收数据. 所以, 第二次调用write方法(假设在收到RST之后), 会生成SIGPIPE信号, 导致进程退出.
    为了避免进程退出, 可以捕获SIGPIPE信号, 或者忽略它, 给它设置SIG_IGN信号处理函数 signal(SIGPIPE, SIG_IGN);
    这样, 第二次调用write方法时, 会返回-1, 同时errno置为SIGPIPE. 程序便能知道对端已经关闭。实际这个函数的目的就是防止程序收到 SIGPIPE 后自动退出。

问题二

我为什么要使用 EPOLL 来实现呢？

    我来回答一下，首先我们假设我们使用同步的方式来进行，如果使用串行的方式，那么请听我的分析，我们都知道，比如你百度一下，那么就只会发过来一条连接吗？肯定不是的，在我们的Web 端，请求一个网页的时候，会发过去很多请求，因为一个网页上比如有些图片比较大，那么会单独起一条连接。
    因此如果使用串行的话，访问一个页面，比如说我发起了5个连接，当我处理第一个连接的时候，其余的四个连接就只能等着。加入我前面的连接处理的比较慢的话，那么等到我有时间去处理第五个连接时，由于时间太久，这条连接会被重置。
    这时有人说了，串行的不行，那么我们改用并行啊，好啊，当然可以啊，那么你封装线程池啊，进程池啊。不过我提醒各位啊，你访问个百度，比如说要来10个请求，这还是往少了的算。那么你开10个网页，那么至少100个请求，一次性来的哦。停！这时是我一个人去请求我的socks 服务器的。比如说我100个人呢，一次性10000个请求，emmmmmm，况且这时常态话的哦，我还需要维持连接的哦。这时有的杠精说了，我一台服务器干不了，我再来一台。好！我无话可说。有钱。
    于是乎，我使用异步的行为，有人就说了，你异步咋了，来10000个连接你就可以同时处理吗？啊，不好意思，不能。但是这些链接我可以收的下。同时还有一点，使用线程池的话，多线程可能会引出更多的问题，比如处理同一条连接的时候要加锁，如果要加锁，那么就有可能出现死锁，emmmm。
    那么最好的解决方案是啥呢，我们可以在使用异步的过程中再加上线程池多线程的处理，会更加高效一点。
    而且我们确定一下，不一定使用epoll 就是出于性能的缘故，有时候我们需要根据具体情况来具体决定。

问题三

    来解决一下发送数据或者接受数据会出现的问题，其实也就是在考察那几个 IO 函数的具体用法。

接收数据时我一次接收多少数据比较好？发送数据时一次发不完怎么办？recv 接收到 0 是什么情况？

    接收数据的时候如果buff 太小的话，可能会出现多次接收的情况。如果多次接收的话会导致效率太低。但是如果buff 太大的话，拿到这么多数据之后转发出去的时候，可能一次发不完，那么这样的话发送就会效率变慢。
    发送数据的时候一次发完最好，一次发不完的处理办法，我是这样解决的，我在我的通道中不仅有文件描述符还有我的缓冲区。如果一次写不完，那么我就把我没有写完的数据放到我的缓冲区中去并且将这个文件描述符继续添加到Epoll 事件中去。
    如果说 recv 接收到一个 0 。也就是说我的client 端不会再给我的server 端发送数据了，于是乎我们应该做的操作就应该是关闭服务器向 server 端套接字的写。并且将客户端的套接字从通道中移除掉。

    
